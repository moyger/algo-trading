//@version=6
strategy("21/50 EMA Pullback — ATR Stop + 21EMA Exit (Auto-Alerts)",
  overlay=true,
  initial_capital=100000,
  commission_type=strategy.commission.percent,
  commission_value=0.02,                   // Bybit futures taker ≈ 0.055%
  pyramiding=0,
  calc_on_order_fills=true,
  calc_on_every_tick=true)

// ===== Inputs =====
len21        = input.int(21,  "EMA Fast (Pullback)", minval=1)
len50        = input.int(50,  "EMA Trend Filter",    minval=1)
enableShorts = input.bool(true, "Enable Shorts")

atrLen       = input.int(14, "ATR Length", minval=1)
atrMultSL    = input.float(2.0, "ATR Stop Multiplier", step=0.1)

useRiskSize  = input.bool(true, "Size by Risk % of Equity")
riskPct      = input.float(0.5, "Risk % per Trade", step=0.1)      // e.g., 0.5 = 0.5%

// ===== Trailing Stop Settings =====
useTrailingStop = input.bool(true, "Use Trailing Stop")
trailMultiplier = input.float(1.5, "Trailing Stop ATR Multiplier", step=0.1)

// ===== Take Profit Settings =====
useTakeProfit = input.bool(false, "Use Take Profit (ATR)")
atrMultTP = input.float(3.0, "ATR Take Profit Multiplier", step=0.1)

// ===== ADX Trend Strength Filter =====
useADX = input.bool(false, "Use ADX Filter")
adxLength = input.int(14, "ADX Length", minval=5, maxval=50)
adxThreshold = input.float(25.0, "ADX Threshold", minval=10.0, maxval=50.0, step=0.5)

// ===== Core calcs =====
ema21 = ta.ema(close, len21)
ema50 = ta.ema(close, len50)
atr   = ta.atr(atrLen)

// ===== ADX Calculation =====
adxCalc(length) =>
    // True Range
    tr = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
    
    // +DM and -DM
    dmPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high - nz(high[1]), 0) : 0
    dmMinus = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz(low[1]) - low, 0) : 0
    
    // Smoothed values using Wilder's smoothing
    trSmooth = 0.0
    trSmooth := nz(trSmooth[1]) - nz(trSmooth[1]) / length + tr
    
    dmPlusSmooth = 0.0
    dmPlusSmooth := nz(dmPlusSmooth[1]) - nz(dmPlusSmooth[1]) / length + dmPlus
    
    dmMinusSmooth = 0.0
    dmMinusSmooth := nz(dmMinusSmooth[1]) - nz(dmMinusSmooth[1]) / length + dmMinus
    
    // DI+ and DI-
    diPlus = dmPlusSmooth / trSmooth * 100
    diMinus = dmMinusSmooth / trSmooth * 100
    
    // DX and ADX
    dx = math.abs(diPlus - diMinus) / (diPlus + diMinus) * 100
    adx = ta.sma(dx, length)
    
    [adx, diPlus, diMinus]

// Calculate ADX values
[adx, diPlus, diMinus] = adxCalc(adxLength)
adxStrong = adx > adxThreshold

// ===== Trailing Stop Variables =====
var float tradeStopLoss = na
var bool stopLossTriggered = false
var bool emaExitTriggered = false
slDistance = atrMultSL * atr
trailDistance = trailMultiplier * atr

trendUp   = close > ema50 and ema21 > ema50
trendDown = close < ema50 and ema21 < ema50

pulledBackUp   = low  <= ema21
pulledBackDown = high >= ema21
crossUp        = ta.crossover(close, ema21)
crossDown      = ta.crossunder(close, ema21)

// Apply ADX filter if enabled
adxFilter = not useADX or adxStrong

longTrigger  = trendUp   and pulledBackUp   and crossUp and adxFilter
shortTrigger = trendDown and pulledBackDown and crossDown and adxFilter

// ===== Position sizing (risk %) =====
riskValue  = strategy.equity * (riskPct/100.0)
qtyByRisk  = (not na(slDistance) and slDistance > 0) ? riskValue / slDistance : na
orderQty() =>
    useRiskSize and not na(qtyByRisk) and qtyByRisk > 0 ? qtyByRisk : 1

// ===== Entries =====
canTakeTrade = strategy.position_size == 0 and not na(atr) and not na(ema21)

if canTakeTrade
    // Reset trailing stop before new trade
    tradeStopLoss := na
    
    // LONG ENTRY
    if longTrigger
        strategy.entry("Long", strategy.long, qty=orderQty())
        // Set initial stop loss
        tradeStopLoss := close - slDistance
        
    // SHORT ENTRY  
    if enableShorts and shortTrigger
        strategy.entry("Short", strategy.short, qty=orderQty())
        // Set initial stop loss
        tradeStopLoss := close + slDistance

// ===== Trailing Stop Logic =====
if strategy.position_size > 0
    // LONG POSITION - Update trailing stop
    if useTrailingStop and barstate.isconfirmed
        newLongSL = low - trailDistance
        if newLongSL > tradeStopLoss
            tradeStopLoss := newLongSL
    
    // Check if stop was hit
    if low <= tradeStopLoss and not na(tradeStopLoss)
        stopLossTriggered := true
        emaExitTriggered := false
    
    // LONG STOP LOSS & TAKE PROFIT
    if useTrailingStop
        if useTakeProfit
            strategy.exit("L-Trail", from_entry="Long", stop=tradeStopLoss, limit=strategy.position_avg_price + atrMultTP*atr)
        else
            strategy.exit("L-Trail", from_entry="Long", stop=tradeStopLoss)
    else
        if useTakeProfit
            strategy.exit("L-Stop", from_entry="Long", stop=strategy.position_avg_price - atrMultSL*atr, limit=strategy.position_avg_price + atrMultTP*atr)
        else
            strategy.exit("L-Stop", from_entry="Long", stop=strategy.position_avg_price - atrMultSL*atr)

if strategy.position_size < 0
    // SHORT POSITION - Update trailing stop  
    if useTrailingStop and barstate.isconfirmed
        newShortSL = high + trailDistance
        if newShortSL < tradeStopLoss
            tradeStopLoss := newShortSL
    
    // Check if stop was hit
    if high >= tradeStopLoss and not na(tradeStopLoss)
        stopLossTriggered := true
        emaExitTriggered := false
            
    // SHORT STOP LOSS & TAKE PROFIT
    if useTrailingStop
        if useTakeProfit
            strategy.exit("S-Trail", from_entry="Short", stop=tradeStopLoss, limit=strategy.position_avg_price - atrMultTP*atr)
        else
            strategy.exit("S-Trail", from_entry="Short", stop=tradeStopLoss)
    else
        if useTakeProfit
            strategy.exit("S-Stop", from_entry="Short", stop=strategy.position_avg_price + atrMultSL*atr, limit=strategy.position_avg_price - atrMultTP*atr)
        else
            strategy.exit("S-Stop", from_entry="Short", stop=strategy.position_avg_price + atrMultSL*atr)

// ===== EMA trailing exit =====
exitLong  = strategy.position_size > 0 and close < ema21
exitShort = strategy.position_size < 0 and close > ema21
if exitLong
    emaExitTriggered := true
    stopLossTriggered := false
    strategy.close("Long")
if exitShort
    emaExitTriggered := true
    stopLossTriggered := false
    strategy.close("Short")

// Reset triggers when no position
if strategy.position_size == 0
    stopLossTriggered := false
    emaExitTriggered := false

// ===== Visuals =====
plot(ema21, "EMA 21", color=color.new(color.teal, 0), linewidth=2)
plot(ema50, "EMA 50", color=color.new(color.orange, 0), linewidth=2)
plot(tradeStopLoss, "Trailing Stop", color=color.red, style=plot.style_linebr, linewidth=1)

plotshape(longTrigger,  title="Long Entry",  style=shape.triangleup,   location=location.belowbar, size=size.tiny, color=color.new(color.teal, 0),   text="L")
plotshape(shortTrigger, title="Short Entry", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.orange, 0), text="S")

// ===== Exit Type Indicators =====
plotshape(stopLossTriggered and strategy.position_size == 0, title="Stop Loss Hit", style=shape.xcross, location=location.abovebar, size=size.normal, color=color.red, text="SL")
plotshape(emaExitTriggered and strategy.position_size == 0, title="EMA Exit", style=shape.circle, location=location.abovebar, size=size.small, color=color.blue, text="EMA")

// ===== ADX Visual Indicators =====
// ADX strength indicator - small dot when strong trend detected
plotshape(useADX and adxStrong ? high + atr*0.1 : na, title="Strong Trend (ADX)", 
          style=shape.circle, location=location.absolute, size=size.tiny, 
          color=color.new(color.yellow, 30), text="")

// ADX value label (optional - can be toggled)
showADXLabel = input.bool(false, "Show ADX Value Label")
if showADXLabel and useADX and barstate.islast
    label.new(bar_index, high + atr*0.3, 
              text="ADX: " + str.tostring(math.round(adx, 1)) + (adxStrong ? " ✓" : " ✗"), 
              color=adxStrong ? color.new(color.green, 80) : color.new(color.red, 80),
              textcolor=color.white, size=size.small, style=label.style_label_down)

// ===== Human-readable alerts (optional) =====
alertcondition(longTrigger,  title="Long Entry",  message="Long: 21 EMA reclaim in 50 EMA uptrend")
alertcondition(exitLong,     title="Long Exit",   message="Long exit: Close below 21 EMA")
alertcondition(shortTrigger, title="Short Entry", message="Short: 21 EMA reject in 50 EMA downtrend")
alertcondition(exitShort,    title="Short Exit",  message="Short exit: Close above 21 EMA")

// ===== Automated Webhook Alerts to Cloudflare =====
tvToken = "k9P$Xz83!vW@b12N#rTe"   // must match WEBHOOK_SECRET in Worker
acctKey = "FTMO"

// Risk sent as USD-equivalent; EA converts to lots
_rv     = strategy.equity * (riskPct/100.0)
_slDist = atrMultSL * atr
qtyUSD  = (not na(_slDist) and _slDist > 0) ? math.round(_rv / _slDist) : 0

mkMsg(evt, side, slPrice) =>
    // build JSON string safely over multiple lines
    s = '{"token":"' + tvToken + '",'
    s += '"account":"' + acctKey + '",'
    s += '"event":"' + evt + '",'
    s += '"symbol":"' + syminfo.ticker + '",'
    s += '"side":"' + side + '",'
    s += '"qty_usd":' + str.tostring(qtyUSD) + ','
    s += '"sl":' + str.tostring(slPrice, "#.####") + ','
    s += '"price":' + str.tostring(close, "#.####") + ','
    s += '"atr":' + str.tostring(atr, "#.####") + ','
    s += '"adx":' + (useADX ? str.tostring(math.round(adx, 1)) : "0") + ','
    s += '"adx_filter":' + (useADX ? "true" : "false") + ','
    s += '"magic":123456,'
    s += '"tag":"21-50-ATR' + (useADX ? '-ADX' : '') + '",'
    s += '"oid":"' + str.tostring(time) + '-' + evt + '-' + side + '",'
    s += '"ts":' + str.tostring(time) + '}'
    s


// Triggers (one alert per bar close)
newLong    = longTrigger  and strategy.position_size <= 0
newShort   = shortTrigger and strategy.position_size >= 0
closeLong  = exitLong
closeShort = exitShort

// Use current close for pre-entry SL reference
// Ensure SL values are properly formatted with correct decimal places
if newLong
    slPrice = math.round((close - (atrMultSL*atr)) * 10000) / 10000  // SL below price for BUY
    alert(mkMsg("entry","BUY", slPrice),  alert.freq_once_per_bar_close)
if newShort
    slPrice = math.round((close + (atrMultSL*atr)) * 10000) / 10000  // SL above price for SELL
    alert(mkMsg("entry","SELL", slPrice),  alert.freq_once_per_bar_close)

// Exits just flatten; SL not needed
if closeLong
    alert(mkMsg("exit","SELL", 0.0), alert.freq_once_per_bar_close)
if closeShort
    alert(mkMsg("exit","BUY", 0.0), alert.freq_once_per_bar_close)