// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading
// @version=6
// @description A collection of custom tools & utility functions commonly used with my scripts
library("ZenLibrary")

// --- BEGIN UTILITY FUNCTIONS {
// @function Calculates how many decimals are on the quote price of the current market
// @returns The current decimal places on the market quote price
export getDecimals() => 
    float _return = math.abs(math.log(syminfo.mintick) / math.log(10))

// @function Calculates the pip size of the current market
// @param multiplier The mintick point multiplier (1 by default, 10 for FX/Crypto/CFD but can be used to override when certain markets require)
// @returns The pip size for the current market
export getPipSize(int multiplier = 1) => 
    float _return = syminfo.mintick * ((multiplier == 1 and (syminfo.type == "forex" or syminfo.type == "crypto" or syminfo.type == "cfd")) ? 10 : multiplier)

// @function Truncates (cuts) excess decimal places
// @param number The number to truncate
// @param decimalPlaces (default=2) The number of decimal places to truncate to
// @returns The given number truncated to the given decimalPlaces
export truncate(float number, simple float decimalPlaces = 2.0) =>
    factor = math.pow(10, decimalPlaces)
    float _return = int(number * factor) / factor

// @function Converts pips into whole numbers
// @param number The pip number to convert into a whole number
// @returns The converted number
export toWhole(float number) =>
    float _return = number / getPipSize() / syminfo.pointvalue

// @function Converts whole numbers back into pips
// @param number The whole number to convert into pips
// @returns The converted number
export toPips(float number) =>
    float _return = number * syminfo.mintick * (syminfo.type == "forex" or syminfo.type == "crypto" ? 10 : 1)

// @function Gets the percentage change between 2 float values over a given lookback period
// @param value1 The first value to reference
// @param value2 The second value to reference
// @param lookback The lookback period to analyze
// @returns The percent change over the two values and lookback period
export getPctChange(float value1, float value2, int lookback) =>
    vChange = value1 - value2
    vDiff   = vChange - vChange[lookback]
    float _return = (vDiff / vChange) * 100

// @function Wichmann–Hill Pseudo-Random Number Generator
// @param minRange The smallest possible number (default: 0)
// @param maxRange The largest possible number (default: 1)
// @returns A random number between minRange and maxRange
export random(float minRange = 0, float maxRange = 1) =>
    float seed = (timenow % 1000000) + (volume % 1000000)
    float germinate = seed * math.random(low, high, 33) * timenow
    float s1 = na, s1 := 171.0 * nz(s1[1], germinate) % 30269.0
    float s2 = na, s2 := 172.0 * nz(s2[1], s1 * seed) % 30307.0
    float s3 = na, s3 := 170.0 * nz(s3[1], s2 * seed) % 30323.0
    float combined = (s1 / 30269.0 + s2 / 30307.0 + s3 / 30323.0) % 1.0
    float _return = minRange + (combined * (maxRange - minRange))

// } END UTILITY FUNCTIONS
// --- BEGIN TA FUNCTIONS {

// @function Calculates a bullish fibonacci value
// @param priceLow The lowest price point
// @param priceHigh The highest price point
// @param fibRatio The fibonacci % ratio to calculate
// @returns The fibonacci value of the given ratio between the two price points
export bullFib(float priceLow, float priceHigh, float fibRatio = 0.382) => 
    float _return = (priceLow - priceHigh) * fibRatio + priceHigh

// @function Calculates a bearish fibonacci value
// @param priceLow The lowest price point
// @param priceHigh The highest price point
// @param fibRatio The fibonacci % ratio to calculate
// @returns The fibonacci value of the given ratio between the two price points
export bearFib(float priceLow, float priceHigh, float fibRatio = 0.382) => 
    float _return = (priceHigh - priceLow) * fibRatio + priceLow

// @function Gets a Moving Average based on type (! MUST BE CALLED ON EVERY TICK TO BE ACCURATE, don't place in scopes)
// @param length The MA period
// @param maType The type of MA
// @returns A moving average with the given parameters
export getMA(simple int length, string maType) =>
    switch maType
        "EMA" => ta.ema(close, length)
        "SMA" => ta.sma(close, length)
        "HMA" => ta.hma(close, length)
        "WMA" => ta.wma(close, length)
        "VWMA" => ta.vwma(close, length)
        "VWAP" => ta.vwap
        => 
            e1 = ta.ema(close, length)
            e2 = ta.ema(e1, length)
            2 * e1 - e2

// @function Counts how many candles are above the MA
// @param lookback The lookback period to look back over
// @param ma The moving average to check
// @returns The bar count of how many recent bars are above the MA
export barsAboveMA(int lookback, float ma) =>
    counter = 0
    for i = 1 to lookback by 1
        if close[i] > ma[i]
            counter := counter + 1
    int _return = counter

// @function Counts how many candles are below the MA
// @param lookback The lookback period to look back over
// @param ma The moving average to reference
// @returns The bar count of how many recent bars are below the EMA
export barsBelowMA(int lookback, float ma) =>
    counter = 0
    for i = 1 to lookback by 1
        if close[i] < ma[i]
            counter := counter + 1
    int _return = counter

// @function Counts how many times the EMA was crossed recently (based on closing prices)
// @param lookback The lookback period to look back over
// @param ma The moving average to reference
// @returns The bar count of how many times price recently crossed the EMA (based on closing prices)
export barsCrossedMA(int lookback, float ma) =>
    counter = 0
    for i = 1 to lookback by 1
        if open[i] > ma[i] and close[i] < ma[i] or open[i] < ma[i] and close[i] > ma[i]
            counter := counter + 1
    int _return = counter

// @function Counts how many green & red bars have printed recently (ie. pullback count)
// @param lookback The lookback period to look back over
// @param direction The color of the bar to count (1 = Green, -1 = Red)
// @returns The bar count of how many candles have retraced over the given lookback & direction
export getPullbackBarCount(int lookback, int direction) =>
    recentCandles = 0
    for i = 1 to lookback by 1
        if direction == 1 and close[i] > open[i]  // Count green bars
            recentCandles := recentCandles + 1
        if direction == -1 and close[i] < open[i]  // Count red bars
            recentCandles := recentCandles + 1
    int _return = recentCandles

// @function Gets the current candle's body size (in POINTS, divide by 10 to get pips)
// @returns The current candle's body size in POINTS
export getBodySize() => 
    float _return = math.abs(close - open) / syminfo.mintick

// @function Gets the current candle's top wick size (in POINTS, divide by 10 to get pips)
// @returns The current candle's top wick size in POINTS
export getTopWickSize() => 
    float _return = math.abs(high - (close > open ? close : open)) / syminfo.mintick

// @function Gets the current candle's bottom wick size (in POINTS, divide by 10 to get pips)
// @returns The current candle's bottom wick size in POINTS
export getBottomWickSize() => 
    float _return = math.abs((close < open ? close : open) - low) / syminfo.mintick

// @function Gets the current candle's body size as a percentage of its entire size including its wicks
// @returns The current candle's body size percentage
export getBodyPercent() => 
    float _return = math.abs(open - close) / math.abs(high - low)

// } END TA FUNCTIONS
// --- BEGIN CANDLE SETUP DETECTION {

// @function Checks if the current bar is a hammer candle based on the given parameters
// @param fib (default=0.382) The fib to base candle body on
// @param colorMatch (default=false) Does the candle need to be green? (true/false)
// @returns A boolean - true if the current bar matches the requirements of a hammer candle
export isHammer(float fib = 0.382, bool colorMatch = false) =>
    bullFib = bullFib(low, high, fib)
    lowestBody = close < open ? close : open
    bool _return = lowestBody >= bullFib and (not colorMatch or close > open)

// @function Checks if the current bar is a shooting star candle based on the given parameters
// @param fib (default=0.382) The fib to base candle body on
// @param colorMatch (default=false) Does the candle need to be red? (true/false)
// @returns A boolean - true if the current bar matches the requirements of a shooting star candle
export isStar(float fib = 0.382, bool colorMatch = false) =>
    bearFib = bearFib(low, high, fib)
    highestBody = close > open ? close : open
    bool _return = highestBody <= bearFib and (not colorMatch or close < open)
    
// @function Checks if the current bar is a doji candle based on the given parameters
// @param wickSize (default=2) The maximum top wick size compared to the bottom (and vice versa)
// @param bodySize (default=0.05) The maximum body size as a percentage compared to the entire candle size
// @returns A boolean - true if the current bar matches the requirements of a doji candle
export isDoji(float wickSize = 2.0, float bodySize = 0.05) =>
    bool _return = getTopWickSize() <= getBottomWickSize() * wickSize and getBottomWickSize() <= getTopWickSize() * wickSize and getBodyPercent() <= bodySize

// @function Checks if the current bar is a bullish engulfing candle
// @param allowance (default=0) How many POINTS to allow the open to be off by (useful for markets with micro gaps)
// @param rejectionWickSize (default=disabled) The maximum rejection wick size compared to the body as a percentage
// @param engulfWick (default=false) Does the engulfing candle require the wick to be engulfed as well?
// @returns A boolean - true if the current bar matches the requirements of a bullish engulfing candle
export isBullishEC(float allowance = 0.0, float rejectionWickSize = 0.0, bool engulfWick = false) =>
    bool _return = (close[1] <= open[1] and close >= open[1] and open <= close[1] + allowance) and (not engulfWick or close >= high[1]) and 
                   (rejectionWickSize == 0.0 or getTopWickSize() / getBodySize() < rejectionWickSize)

// @function Checks if the current bar is a bearish engulfing candle
// @param allowance (default=0) How many POINTS to allow the open to be off by (useful for markets with micro gaps)
// @param rejectionWickSize (default=disabled) The maximum rejection wick size compared to the body as a percentage
// @param engulfWick (default=false) Does the engulfing candle require the wick to be engulfed as well?
// @returns A boolean - true if the current bar matches the requirements of a bearish engulfing candle
export isBearishEC(float allowance = 0.0, float rejectionWickSize = 0.0, bool engulfWick = false) =>
    bool _return = (close[1] >= open[1] and close <= open[1] and open >= close[1] - allowance) and (not engulfWick or close <= low[1]) and
                   (rejectionWickSize == 0.0 or getBottomWickSize() / getBodySize() < rejectionWickSize)

// @function Detects inside bars
// @returns Returns true if the current bar is an inside bar
export isInsideBar() => 
    bool _return = high < high[1] and low > low[1]

// @function Detects outside bars
// @returns Returns true if the current bar is an outside bar
export isOutsideBar() => 
    bool _return = high > high[1] and low < low[1]

// } END CANDLE SETUP DETECTION
// --- BEGIN FILTER FUNCTIONS {

// @function Determines if the current price bar falls inside the specified session
// @param sess The session to check
// @param useFilter (default=true) Whether or not to actually use this filter
// @returns A boolean - true if the current bar falls within the given time session
export barInSession(simple string sess, bool useFilter = true) => 
    bool _return = na(time(timeframe.period, sess + ":1234567")) == false or not useFilter

// @function Determines if the current price bar falls outside the specified session
// @param sess The session to check
// @param useFilter (default=true) Whether or not to actually use this filter
// @returns A boolean - true if the current bar falls outside the given time session
export barOutSession(simple string sess, bool useFilter = true) => 
    bool _return = na(time(timeframe.period, sess + ":1234567")) or not useFilter

// @function Determines if this bar's time falls within date filter range
// @param startTime The UNIX date timestamp to begin searching from
// @param endTime the UNIX date timestamp to stop searching from
// @returns A boolean - true if the current bar falls within the given dates
export dateFilter(int startTime, int endTime) => 
    bool _return = time >= startTime and time <= endTime

// @function Checks if the current bar's day is in the list of given days to analyze
// @param monday Should the script analyze this day? (true/false)
// @param tuesday Should the script analyze this day? (true/false)
// @param wednesday Should the script analyze this day? (true/false)
// @param thursday Should the script analyze this day? (true/false)
// @param friday Should the script analyze this day? (true/false)
// @param saturday Should the script analyze this day? (true/false)
// @param sunday Should the script analyze this day? (true/false)
// @returns A boolean - true if the current bar's day is one of the given days
export dayFilter(bool monday, bool tuesday, bool wednesday, bool thursday, bool friday, bool saturday, bool sunday) => 
    bool _return = (dayofweek == dayofweek.monday and monday or
         dayofweek == dayofweek.tuesday and tuesday or
         dayofweek == dayofweek.wednesday and wednesday or
         dayofweek == dayofweek.thursday and thursday or
         dayofweek == dayofweek.friday and friday or
         dayofweek == dayofweek.saturday and saturday or
         dayofweek == dayofweek.sunday and sunday)

// @function Checks the current bar's size against the given ATR and max size
// @param atrValue (default=ATR 14 period) The given ATR to check
// @param maxSize The maximum ATR multiplier of the current candle
// @returns A boolean - true if the current bar's size is less than or equal to atr x maxSize
float _atr = ta.atr(14)
export atrFilter(float atrValue = 1111, float maxSize) => 
    bool _return = maxSize == 0 or math.abs(high - low) <= (atrValue == 1111 ? _atr : atrValue) * maxSize

// } END FILTER FUNCTIONS

// --- BEGIN STRATEGY FUNCTIONS {

// @function Calculate total trade count
// @returns Total closed trade count
export tradeCount() =>
    int _return = strategy.closedtrades

// @function Check if we're currently in a long trade
// @returns True if our position size is positive
export isLong() =>
    bool _return = strategy.position_size > 0

// @function Check if we're currently in a short trade
// @returns True if our position size is negative
export isShort() =>
    bool _return = strategy.position_size < 0

// @function Check if we're currentlyflat
// @returns True if our position size is zero
export isFlat() =>
    bool _return = strategy.position_size == 0

// @function Check if this bar falls after a winning trade
// @returns True if we just won a trade
export wonTrade() =>
    bool _return = strategy.wintrades != strategy.wintrades[1]

// @function Check if this bar falls after a losing trade
// @returns True if we just lost a trade
export lostTrade() =>
    bool _return = strategy.losstrades != strategy.losstrades[1]

// @function Gets the max drawdown based on closed trades (ie. realized P&L). The strategy tester displays max drawdown as open P&L (unrealized).
// @returns The max drawdown based on closed trades (ie. realized P&L). The strategy tester displays max drawdown as open P&L (unrealized).
export maxDrawdownRealized() =>
    float _return = 0
    float equityPeak = strategy.initial_capital
    float currentEquity = strategy.initial_capital
    for i = 0 to strategy.closedtrades - 1 by 1
        // Update current equity with each closed trade
        currentEquity := currentEquity + strategy.closedtrades.profit(i)
        // Update the highest equity peak
        if currentEquity > equityPeak
            equityPeak := currentEquity
        // Calculate the drawdown from the peak
        float drawdown = 100 * (equityPeak - currentEquity) / equityPeak
        // Update the maximum drawdown if the current drawdown is larger
        if drawdown > _return
            _return := drawdown
    _return := _return

// @function Gets the total amount of pips won/lost (as a whole number)
// @returns Total amount of pips won/lost (as a whole number)
export totalPipReturn() =>
    float totalPips = 0
    for i = 0 to strategy.closedtrades - 1 by 1
        if (strategy.closedtrades.exit_price(i) > strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) > 0)
            totalPips := totalPips + (strategy.closedtrades.exit_price(i) - strategy.closedtrades.entry_price(i)) // Long win
        else if (strategy.closedtrades.exit_price(i) < strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) > 0)
            totalPips := totalPips + ((strategy.closedtrades.entry_price(i) - strategy.closedtrades.exit_price(i))) // Short win
        else if (strategy.closedtrades.exit_price(i) < strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) < 0)
            totalPips := totalPips + ((strategy.closedtrades.entry_price(i) - strategy.closedtrades.exit_price(i)) * -1) // Long loss
        else if (strategy.closedtrades.exit_price(i) > strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) < 0)
            totalPips := totalPips + ((strategy.closedtrades.exit_price(i) - strategy.closedtrades.entry_price(i)) * -1) // Short loss
    float _return = toWhole(totalPips)

// @function Count how many winning long trades we've had
// @returns Long win count
export longWinCount() =>
    int _return = 0
    for i = 0 to strategy.closedtrades by 1
        if (strategy.closedtrades.exit_price(i) > strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) > 0)
            _return := _return + 1
    _return

// @function Count how many winning short trades we've had
// @returns Short win count
export shortWinCount() =>
    int _return = 0
    for i = 0 to strategy.closedtrades by 1
        if (strategy.closedtrades.exit_price(i) < strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) > 0)
            _return := _return + 1
    _return

// @function Count how many losing long trades we've had
// @returns Long loss count
export longLossCount() =>
    int _return = 0
    for i = 0 to strategy.closedtrades by 1
        if (strategy.closedtrades.exit_price(i) < strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) < 0)
            _return := _return + 1
    _return

// @function Count how many losing short trades we've had
// @returns Short loss count
export shortLossCount() =>
    int _return = 0
    for i = 0 to strategy.closedtrades by 1
        if (strategy.closedtrades.exit_price(i) > strategy.closedtrades.entry_price(i) and strategy.closedtrades.profit(i) < 0)
            _return := _return + 1
    _return

// @function Count how many break-even trades we've had
// @param allowanceTicks Optional - how many ticks to allow between entry & exit price (default 0)
// @returns Break-even count
export breakEvenCount(float allowanceTicks = 0) =>
    int _return = 0
    for i = 0 to strategy.closedtrades - 1 by 1
        entryPrice = strategy.closedtrades.entry_price(i)
        exitPrice = strategy.closedtrades.exit_price(i)
        if (math.abs(exitPrice - entryPrice) <= (allowanceTicks * syminfo.mintick))
            _return := _return + 1
    _return

// @function Count how many long trades we've taken
// @returns Long trade count
export longCount() =>
    int _return = longWinCount() + longLossCount()

// @function Count how many short trades we've taken
// @returns Short trade count
export shortCount() =>
    int _return = shortWinCount() + shortLossCount()

// @function Calculate win rate of long trades
// @returns Long win rate (0-100)
export longWinPercent() =>
    float _return = (longWinCount() / longCount()) * 100
    
// @function Calculate win rate of short trades
// @returns Short win rate (0-100)
export shortWinPercent() =>
    float _return = (shortWinCount() / shortCount()) * 100

// @function Calculate break even rate of all trades
// @param allowanceTicks Optional - how many ticks to allow between entry & exit price (default 0)
// @returns Break-even win rate (0-100)
export breakEvenPercent(float allowanceTicks = 0) =>
    float _return = (breakEvenCount(allowanceTicks) / tradeCount()) * 100

// @function Calculate average risk:reward
// @returns Average winning trade divided by average losing trade
export averageRR() =>
    float _return = strategy.avg_winning_trade / strategy.avg_losing_trade

// @function (Forex) Convert the given unit count to lots (multiples of 100,000)
// @param units The units to convert into lots
// @returns Units converted to nearest lot size (as float)
export unitsToLots(float units) =>
    float lots = units / 100000
    lots := math.round(lots, 2)
    _return = lots * 100000

// @function (Forex) Calculate fixed-fractional position size based on given parameters
// @param balance The account balance
// @param risk The % risk (whole number)
// @param stopLossPips Pip distance to base risk on
// @param lots Whether or not to return the position size in lots rather than units (true by default)
// @param fxRate The conversion currency rate (-1 by default - script will auto-detect FX conversion pair, more info below in library documentation)
// @param symbolOverride Directly specify the symbol to use for currency conversion (blank by default)
// @param useCurrentTF Use the matching intrabar for currency conversion instead of daily FX data - note: this will give more accurate conversion FX rates, but limits bar replay functionality
// @returns Units/lots to enter into "qty=" parameter of strategy entry function
//
// EXAMPLE USAGE:
//
// if (longCondition) // Risk 1%
//     strategy.entry("Long", strategy.long, qty=zen.getFxPositionSize(1, stopLossPipsWholeNumber, true, strategy.equity))
export getFxPositionSize(float risk, float stopLossPips, bool lots = true, float balance = -1, float fxRate = -1, string symbolOverride = "", bool useCurrentTF = false) =>
    _balance = balance
    if (balance == -1)
        _balance := strategy.equity

    // Get FX rate based on current market
    _fxRate = fxRate
    if (fxRate == -1 or symbolOverride != "")
        string conversionCurrencyPair = (strategy.account_currency == syminfo.currency ? syminfo.tickerid : strategy.account_currency + syminfo.currency)
        if (symbolOverride != "")
            conversionCurrencyPair := symbolOverride
        _fxRate := request.security(conversionCurrencyPair, useCurrentTF ? timeframe.period : "D", close[barstate.isrealtime ? 1 : 0])[barstate.isrealtime ? 0 : 1]
                                                                                                  
    // Define risk percentage
    float riskPercentage = risk / 100
    float riskDollars = _balance * riskPercentage

    // Calculate the pip value * lot size
    float pipValue = getPipSize() * 100000

    // Adjust pip value for currency conversion if necessary
    if (strategy.account_currency != syminfo.currency)
        pipValue := pipValue / _fxRate

    // Calculate the position size in units to risk 1% of account balance
    float positionSize = math.round(riskDollars / ((stopLossPips * pipValue) / 100000))
    if (lots)
        positionSize := unitsToLots(positionSize)

    // Return position size
    float _return = math.round(positionSize)
    _return

// @function Checks to see if trade should be skipped to emulate rudimentary Monte Carlo simulation
// @param chance The chance to skip a trade (0-1 or 0-100, function will normalize to 0-1)
// @param debug Whether or not to display a label informing of the trade skip
// @returns True if the trade is skipped, false if it's not skipped (idea being to include this function in entry condition validation checks)
export skipTradeMonteCarlo(float chance = 0.01, bool debug = true) =>
    bool _return = false
    float _chance = chance
    if (_chance < 0)
        _chance := 0
    if (_chance > 1)
        if (_chance > 100)
            _chance := 100
        _chance := _chance / 100
    if (random() <= _chance)
        _return := true
        if (debug)
            label.new(bar_index, high, 
                 text="SKIPPED!", 
                 tooltip="This trade was skipped due to monte carlo simulation!", 
                 style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)
    _return
// } END STRATEGY FUNCTIONS --- //

// --- BEGIN DISPLAY FUNCTIONS {

// @function This updates the given table's cell with the given values
// @param tableID The table ID to update
// @param column The column to update
// @param row The row to update
// @param title The title of this cell
// @param value The value of this cell
// @param bgcolor The background color of this cell
// @param txtcolor The text color of this cell
// @returns Nothing.
export fillCell(table tableID, int column, int row, string title, string value, color bgcolor, color txtcolor, string tooltip = na) =>
    cellText = title + "\n" + value
    table.cell(tableID, column, row, cellText, bgcolor=bgcolor, text_color=txtcolor, tooltip=tooltip)

// } END DISPLAY FUNCTIONS